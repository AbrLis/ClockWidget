# Архитектура изменений: длинный таймер

## 1. Модель данных [Выполнено]
- **LongTimerPersistModel** [Выполнено]
  ```csharp
  /// <summary>
  /// Модель для сериализации длинного таймера.
  /// </summary>
  public class LongTimerPersistModel
  {
      /// <summary>Дата и время срабатывания таймера.</summary>
      public DateTime TargetDateTime { get; set; }
      /// <summary>Включён ли таймер.</summary>
      public bool IsEnabled { get; set; }
  }
  ```
- **TimersAndAlarmsPersistModel** [Выполнено]
  ```csharp
  public List<LongTimerPersistModel> LongTimers { get; set; } = new();
  ```

## 2. ViewModel [Выполнено]
- **LongTimersViewModel** [Выполнено]
  - Коллекция: `ObservableCollection<LongTimerEntryViewModel> LongTimers`
  - Свойства для ввода даты и времени, команды, DI, логика добавления/удаления
- **LongTimerEntryViewModel** [Выполнено]
  - Свойства: `DateTime TargetDateTime`, `TimeSpan Remaining`, команды, DI, форматирование времени, сигнал окончания
- **TimersAndAlarmsViewModel** [Выполнено]
  - Свойство LongTimersVM, DI, интеграция с ISoundService
  - Сохранение и загрузка длинных таймеров
  - Добавить свойство:
    ```csharp
    public LongTimersViewModel LongTimersVM { get; }
    ```
  - Инициализация и методы для сохранения/загрузки длинных таймеров.
  - **Интеграция:** использовать существующие сервисы для хранения, сигналов и времени через DI.

## 3. UI (XAML) [Выполнено]
- **SettingsWindow.xaml** [Выполнено]
  - Добавлен новый раздел (GroupBox) "Длинные таймеры" с поддержкой ввода даты и времени, кнопкой добавления, списком таймеров и кнопками управления
  - Внешний вид и взаимодействие аналогичны разделу Timers, но с поддержкой выбора даты и времени.

## 4. Сервис хранения и интеграция [Выполнено]
- **TimersAndAlarmsPersistenceService** [Выполнено]
  - Сохраняет и загружает LongTimers без изменений
- **ISettingsService, SettingsService** [Выполнено]
  - Поддержка LongTimers реализована через сериализацию TimersAndAlarmsPersistModel
- **ISoundService, ITimeService и др.**
  - Использовать существующие сервисы для воспроизведения сигналов, получения текущего времени и т.д.
  - Все сервисы внедрять через DI для тестируемости и слабой связанности.

## 5. Логика работы [Выполнено]
- Обновление тултипов трея для LongTimers
- Сигнал окончания таймера реализован
- TODO: окно уведомления при срабатывании длинного таймера (аналогично обычному таймеру)
- При запуске приложения:
  - Загружать длинные таймеры из настроек.
  - Для каждого активного таймера вычислять оставшееся время относительно текущего времени.
  - Если время истекло — воспроизводить сигнал и показывать окно оповещения, останавливать таймер.
- При добавлении/редактировании:
  - Сохранять изменения в файл настроек.
- При срабатывании:
  - Воспроизводить сигнал окончания и показывать окно оповещения (аналогично обычному таймеру).
- **Интеграция:** использовать существующую логику уведомлений и окон оповещений для единообразия.

## 6. Тестирование [Выполнено]
- Добавлены юнит-тесты для LongTimersViewModel и LongTimerEntryViewModel (добавление, удаление, запуск, сигнал, корректное вычисление времени)
- **Unit-тесты**
  - Покрыть LongTimersViewModel и LongTimerEntryViewModel тестами на добавление, удаление, запуск, остановку, корректное вычисление оставшегося времени, срабатывание таймера.
  - Использовать мок-сервисы (`ISoundService`, `ITimeService`, `ISettingsService`) для изоляции логики.
- **Интеграционные тесты**
  - Проверить корректную работу сохранения/загрузки длинных таймеров через TimersAndAlarmsPersistenceService и ISettingsService.

## 7. Отображение оставшегося времени
- Для длинных таймеров отображать:  `Xл:Yм:Zд:hh:mm:ss`  (если год/месяц не ноль — показывать, иначе скрывать).

---

### Как будет выглядеть и работать
- В меню настроек появится новый раздел "Длинные таймеры" под разделом Alarm.
- Интерфейс похож на обычные таймеры, но с возможностью выбрать дату и время срабатывания.
- В списке длинных таймеров отображается оставшееся время в расширенном формате.
- По истечении времени — сигнал и окно оповещения, таймер останавливается.
- Все данные сохраняются и восстанавливаются при запуске приложения.
- **Архитектура поддерживает DI и тестирование, интегрируется с существующими сервисами без дублирования логики.** 